However, as you said at the end of the video that you've always wanted to bring Haskell and Excel and teaching together, I thought I'd share a little. If you don't mind, as we haven't launched, keep this to yourself for the moment.


I'm currently working on a competitor/similar market to Excel/Google Sheets aimed at the more savvy spreadsheet users. It'll be a software as a service (like Google Sheets or Excel 365), initially. The concept is that Haskell is the spreadsheet.


* Do not have a special language for writing equations, that you eventually have to switch away from to VBA/JS. Make a powerful language from the beginning.
* Keep the "code vs result" modal switching of the spreadsheet, which is in my opinion, its hugest contribution.
* We drop the grid concept entirely.
* We drop coordinates entirely.
* All cells are regular Haskell values (numbers, vectors, records, tables, directed graphs, trees). This means, like you noted in your talk, people can express more rich ideas than what fits in a grid.
* All cells have names (which is okay when names don't matter; see CAS bullet below).
* Cells are things you can click and drag around on a canvas.
* The language is a tiny (strict) dialect of Haskell with row types, type-classes (for number overloading) that aren't user-definable (yet).
* It has a stepper (like Duet: https://chrisdone.com/toys/duet-delta/), so that it's trivial to follow evaluation. I've done it once so it's easy to know what works. Every evaluation step is one rewrite. Later, I can compile to Haskell (possibly on the fly) for long-running computations.
* I use CAS, as in Unison, so that during the renamer step all lambdas are de Brujin indexed, only lets can be recursive (not top-level names), which means I can hash a declaration (else recursion presents a contradiction). In the end it means all names are replaced with hashes or de Brujin indices (as in Unison). This makes it trivial for me to implement caching and re-calculation schemes across the pipeline (parse, index, rename, generate, solve, generalise (polytypes), resolve (type-classes)) and of course most importantly the stepper. Actual origin locations and names are stored instead as metadata. A rename just updates the metadata.
* It will have a library inspired directly by Prelude and Data.List and the standard patterns there (maps, filters, folds). So I don't have to re-invent the wheel.


Two crucial things come together beautifully, too:


1. All cells in the UI have the code view and result view. But NESTED data structures can be edited in their substructures! You can click the second element of the list and enter some code, arithmetic, or whatever. Or you can edit the LIST as code. You can have a record of a record with a list in it and at any point edit the one bit. The code for it gets rebuilt, like modifying via a lens in Haskell.


2. Row types and arrays is a very attractive starting point for a table. The UI can render an array of rows as a table. Now you can easily edit (well-typed) tabular data again. Not only that, you can easily make derived cells via a quick sortBy or filter or reverse, and use row type accessors to access the columns.


In Excel, "volatile" functions are problematic (NOW(), RANDOM(), etc.). My solution is not fully baked, but sort of baked: I want to re-use the ideas in Reflex, where impure things are streams. The current time is a stream that you sample from at a given rate, and fmap over to get the result. There's no reason that it couldn't show the time ticking live. Button clicks from the user apply here too. Or querying URLs for data. This means the type system can track what in your document is pure and what is "live". When you "close" the document, that state is gone. So it leads to thinking about documents that run in the background as processes.
