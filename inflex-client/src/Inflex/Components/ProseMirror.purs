-- | ProseMirror component.

module Inflex.Components.ProseMirror
  ( component
  , Input, Query, Config, Output
  ) where

import Data.Array (concatMap)
import Data.Either
import Data.Foldable
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.Map (Map)
import Data.Map as M
import Data.Maybe (Maybe(..))
import Data.Symbol (SProxy(..))
import Data.Tuple
import Data.UUID
import Data.UUID (UUID, uuidToString)
import Effect (Effect)
import Effect.Aff (Aff)
import Effect.Aff.Class (class MonadAff)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (log)
import Foreign.Object (Object)
import Halogen (Component, HalogenM, RefLabel(..), defaultEval, get, getHTMLElementRef, liftEffect, mkComponent, mkEval, put, raise, subscribe) as H
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Properties as HP
import Halogen.Portal as Portal
import Halogen.Query.EventSource (effectEventSource, emit) as H
import Inflex.Components.Cell.Editor.Types as EditorTypes
import Inflex.Frisson as F
import Inflex.Types (OutputCell(..))
import Prelude (class Show, Unit, bind, const, discard, mempty, pure, unit, void, (/=), (<<<), identity)
import Web.HTML.HTMLElement (HTMLElement)

--------------------------------------------------------------------------------
-- Interface

type Input = Map UUID OutputCell

type Output = Unit

data Query a = NoOp

--------------------------------------------------------------------------------
-- Internal protocol

type Slots a = (editor :: H.Slot EditorTypes.Query EditorTypes.Output UUID)

data State = State
  { allCells :: Map UUID (OutputCell)

  -- Below: The first UUID is a widget UUID generated by
  -- ProseMirror.js, the latter is an Inflex cell UUID.
  , embedCells :: Map UUID UUID
  }

data Command
  = Initializer
  | SetCells (Map UUID (OutputCell))

--------------------------------------------------------------------------------
-- Types

data Config = Config
  {
  }

foreign import data ProseMirror :: Type

data PMEvent
  = NoEvents

derive instance genericPMEvent :: Generic PMEvent _
instance showPMEvent :: Show PMEvent where show x = genericShow x

--------------------------------------------------------------------------------
-- Constants

refLabel :: H.RefLabel
refLabel = H.RefLabel "prosemirror"

--------------------------------------------------------------------------------
-- Component

component :: forall m. MonadAff m
  => H.Component HH.HTML EditorTypes.Query EditorTypes.Input EditorTypes.Output m
  -> H.Component HH.HTML Query Input Output m
component editorComponent =
  H.mkComponent
    { initialState: initialState
    , render: render editorComponent
    , eval: H.mkEval
              H.defaultEval
                { handleAction = eval
                , receive = pure <<< SetCells
                , initialize = Just Initializer
                , handleQuery = query
                }
    }
  where
    initialState :: Input -> State
    initialState cells = State {
      allCells: cells,
      embedCells: M.fromFoldable [Tuple (UUID "some-unique-id") (UUID "7190914a-9a54-477b-b5dc-da6b73edb7c9")]
     }

--------------------------------------------------------------------------------
-- Query

query ::
     forall m i a. MonadAff m =>
     Query a
  -> H.HalogenM State Command (Slots i) Output m (Maybe a)
query =
  case _ of
    NoOp -> do

      pure Nothing

--------------------------------------------------------------------------------
-- Eval

eval :: forall i t9. MonadEffect t9 => MonadAff t9 => Command -> H.HalogenM State Command (Slots i) Output t9 Unit
-- eval (CMEventIn event) =
--   H.raise (CMEventOut event)
eval (SetCells cells) = H.modify_ (\(State s) -> State (s {allCells = cells}))
eval Initializer = do
  State {} <- H.get
  melement <- H.getHTMLElementRef refLabel
  case melement of
    Nothing -> pure unit
    Just element -> do
      cm <- H.liftEffect (proseMirror element)
      void
        (H.subscribe
           (H.effectEventSource
              (\emitter -> do
                 pure mempty)))

--------------------------------------------------------------------------------
-- Render


render editorComponent (State{embedCells, allCells}) =
  HH.div
    [HP.ref refLabel
    ]
    (concatMap (\(Tuple proseUuid cellUuid) ->
           case M.lookup cellUuid allCells of
             Nothing -> []
             Just (OutputCell cell) ->
               [

                 HH.div
            [HP.class_ (HH.ClassName "cell-body")]
            [ HH.slot
                (SProxy :: SProxy "editor")
                proseUuid
                editorComponent
                (EditorTypes.EditorAndCode
                   { editor:
                     -- TODO: Refactor, the code below is the same as in Cell.purs.
                     F.caseResult
                        { "ResultError": Left
                        , "ResultOk": \resultTree -> Right (F.resultTreeTree resultTree)
                        }
                        (cell.result)
                   , code: cell.code
                   , cells: allCells
                   , path: identity
                   -- TODO: Refactor, the code below is the same as in Cell.purs.
                   , type': F.caseResult
                       { "ResultError": \_ -> Nothing
                       , "ResultOk": \resultTree -> Just (F.resultTreeTyp resultTree)
                       }
                       (cell.result)
                   })
                (\output ->
                   case output of
                     -- TODO: Enable TriggerUpdatePath
                     EditorTypes.UpdatePath update -> Nothing -- Just (TriggerUpdatePath update)
                     -- TODO: Enable TriggerUpdatePath
                     EditorTypes.NewCode text ->
                       Nothing
                       -- Just
                       --   (TriggerUpdatePath
                       --      (Shared.UpdatePath
                       --         { path: Shared.DataHere
                       --         , update:
                       --             Shared.CodeUpdate (Shared.Code {text})
                       --         }))
                )
            ]

                ]
               -- Portal.portalAff
               --   (SProxy :: SProxy "EmbedCell")
               --   (uuidToString proseUuid)
               --   Cell.component
               --   (Cell.Input
               --      { cell: outputCell
               --      , cells:
               --          M.delete
               --            uuid
               --            (M.fromFoldable
               --               (map
               --                  (\cell'@(OutputCell cell'0) ->
               --                     Tuple ((cell'0 . uuid)) cell')
               --                  (state . cells)))
               --      , dragger: emptyDragger unit
               --      })
               -- Nothing -- TODO: change to element from ProseMirror.
               -- (\_ -> Nothing)
         )
         (M.toUnfoldable embedCells))

--------------------------------------------------------------------------------
-- Foreign

foreign import proseMirror
  :: HTMLElement
  -> Effect ProseMirror
