-- | ProseMirror component.

module Inflex.Components.ProseMirror
  ( component
  , Input, Query, Config, Output(..)
  ) where

import Control.Alternative ((<|>))
import Data.Array (concatMap)
import Data.Either
import Data.Foldable
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.Map (Map)
import Data.Map as M
import Data.Maybe (Maybe(..))
import Data.Symbol (SProxy(..))
import Data.Tuple
import Data.UUID
import Data.UUID (UUID, uuidToString)
import Effect (Effect)
import Effect.Aff (Aff)
import Effect.Aff.Class (class MonadAff)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (log)
import Foreign.Object (Object)
import Halogen (Component, HalogenM, RefLabel(..), defaultEval, get, getHTMLElementRef, liftEffect, mkComponent, mkEval, put, raise, subscribe) as H
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.Portal as Portal
import Halogen.Query.EventSource (effectEventSource, emit) as H
import Inflex.Components.Cell.Editor.Types as EditorTypes
import Inflex.Frisson as F
import Inflex.Schema as Shared
import Inflex.Types (OutputCell(..))
import Prelude (class Show, Unit, bind, const, discard, mempty, pure, unit, void, (/=), (<<<), identity, (==), (&&), ($), map, (<>))
import Timed (timed)
import Web.HTML.HTMLElement (HTMLElement)

--------------------------------------------------------------------------------
-- Interface

type Input = {
  cells :: Map UUID OutputCell,
  the_json :: Shared.Json
}

data Output
  = TextOutput String
  | UpdatePath (Maybe UUID) Shared.UpdatePath

data Query a = NoOp

--------------------------------------------------------------------------------
-- Internal protocol

type Slots a = (editor :: H.Slot EditorTypes.Query EditorTypes.Output UUID)

data State = State
  { allCells :: Map UUID (OutputCell)

  -- Below: The first UUID is a widget UUID generated by
  -- ProseMirror.js, the latter is an Inflex cell UUID.
  , embedCells :: Map UUID (Tuple UUID HTMLElement)
  , the_json :: Shared.Json
  , proseMirror :: Maybe ProseMirror
  }

data Command
  = Initializer
  | SetInput Input
  | RegisterWidget UUID UUID HTMLElement
  | TriggerUpdatePath (Maybe UUID) Shared.UpdatePath
  | TriggerTextOutput String
  | InsertCell UUID

--------------------------------------------------------------------------------
-- Types

data Config = Config
  {
  }

data PMEvent
  = NoEvents

derive instance genericPMEvent :: Generic PMEvent _
instance showPMEvent :: Show PMEvent where show x = genericShow x

--------------------------------------------------------------------------------
-- Constants

refLabel :: H.RefLabel
refLabel = H.RefLabel "prosemirror"

--------------------------------------------------------------------------------
-- Component

component ::
     H.Component HH.HTML EditorTypes.Query EditorTypes.Input EditorTypes.Output Aff
  -> H.Component HH.HTML Query Input Output Aff
component editorComponent =
  H.mkComponent
    { initialState: initialState
    , render: \state -> timed "ProseMirror.render" (\_ -> render editorComponent state)
    , eval: H.mkEval
              H.defaultEval
                { handleAction = eval
                , receive = pure <<< SetInput
                , initialize = Just Initializer
                , handleQuery = query
                }
    }
  where
    initialState :: Input -> State
    initialState input = State {
      allCells: input.cells,
      embedCells: mempty,
      the_json: input.the_json,
      proseMirror: Nothing
     }

--------------------------------------------------------------------------------
-- Query

query ::
     forall m i a. MonadAff m =>
     Query a
  -> H.HalogenM State Command (Slots i) Output m (Maybe a)
query =
  case _ of
    NoOp -> do

      pure Nothing

--------------------------------------------------------------------------------
-- Eval

eval :: forall i t9. MonadEffect t9 => MonadAff t9 => Command -> H.HalogenM State Command (Slots i) Output t9 Unit
eval (TriggerUpdatePath muuid event) =
  H.raise (UpdatePath muuid event)
eval (TriggerTextOutput code) =
  H.raise (TextOutput code)
eval (InsertCell uuid) = do
  log "InsertCell in ProseMirror..."
  State {proseMirror} <- H.get
  case proseMirror of
    Just pm -> H.liftEffect $ do
      insertProseMirrorCell (uuidToString uuid) pm
    Nothing -> pure unit
eval (SetInput input) = do
  log "SetInput in ProseMirror..."
  State {allCells, proseMirror} <- H.get
  H.modify_ (\(State s) -> State (s {allCells = input . cells}))
  case proseMirror of
    Just pm -> H.liftEffect $ do
      setProseMirrorInput (input . the_json) pm
    Nothing -> pure unit
eval (RegisterWidget proseUuid cellUuid element) =
   H.modify_ (\(State s) -> State (s {embedCells = M.insert proseUuid (Tuple cellUuid element) (s.embedCells)}))
eval Initializer = do
  State {the_json, allCells} <- H.get
  melement <- H.getHTMLElementRef refLabel
  case melement of
    Nothing -> pure unit
    Just element0 -> do
      creator <- H.liftEffect newCreator
      codeEmitter <- H.liftEffect newCodeEmitter
      void
        (H.subscribe
           (H.effectEventSource
              (\emitter -> do
                 setOnCreate creator (\proseUuid cellUuid element -> H.emit emitter (RegisterWidget (UUID proseUuid) (UUID cellUuid) element))
                 setOnCode codeEmitter (\code -> H.emit emitter (TriggerTextOutput code))
                 pure mempty)))
      pm <- H.liftEffect (proseMirror the_json element0 creator codeEmitter)
      H.modify_ (\(State s) -> State s {proseMirror = pure pm})

--------------------------------------------------------------------------------
-- Render

render editorComponent (State{embedCells, allCells}) =
  HH.div [] [
    HH.div [] ([
              HH.text "Insert: "
              ] <>
              map (\(Tuple _ (OutputCell {name, uuid})) ->
                    HH.button
                      [HE.onClick (\e -> Just (InsertCell uuid))]
                      [HH.text name])
              (M.toUnfoldable allCells)),
    HH.div
        [HP.ref refLabel
        ]
        (concatMap (\(Tuple proseUuid (Tuple cellUuid element)) ->
             case M.lookup cellUuid allCells of
               Nothing -> []
               Just (OutputCell cell) ->
                 [Portal.portalAff
                  EditorTypes.NewInput
                  (SProxy :: SProxy "editor")
                  proseUuid
                  editorComponent
                  (EditorTypes.EditorAndCode
                     { editor:
                       -- TODO: Refactor, the code below is the same as in Cell.purs.
                       F.caseResult
                          { "ResultError": Left
                          , "ResultOk": \resultTree -> Right (F.resultTreeTree resultTree)
                          }
                          (cell.result)
                     , code: cell.code
                     , cells: allCells
                     , path: identity
                     -- TODO: Refactor, the code below is the same as in Cell.purs.
                     , type': F.caseResult
                         { "ResultError": \_ -> Nothing
                         , "ResultOk": \resultTree -> Just (F.resultTreeTyp resultTree)
                         }
                         (cell.result)
                     })
                  (Just element)
                  (\output ->
                     case output of
                       EditorTypes.UpdatePath muuid update ->
                         Just (TriggerUpdatePath (muuid <|> Just cellUuid) update)
                       EditorTypes.NewCode text ->
                         Just
                           (TriggerUpdatePath
                              (Just cellUuid)
                              (Shared.UpdatePath
                                 { path: Shared.DataHere
                                 , update:
                                     Shared.CodeUpdate (Shared.Code {text})
                                 }))
                  )


                  ]
           )
           (M.toUnfoldable embedCells))
    ]

--------------------------------------------------------------------------------
-- Foreign

foreign import proseMirror
  :: Shared.Json
  -> HTMLElement
  -> Creator
  -> CodeEmitter
  -> Effect ProseMirror

foreign import insertProseMirrorCell
  :: String
  -> ProseMirror
  -> Effect Unit

foreign import setProseMirrorInput
  :: Shared.Json
  -> ProseMirror
  -> Effect Unit

foreign import newCreator :: Effect Creator

foreign import setOnCreate
  :: Creator
  -> (String -> String -> HTMLElement -> Effect Unit)
  -> Effect Unit

foreign import newCodeEmitter :: Effect CodeEmitter

foreign import setOnCode
  :: CodeEmitter
  -> (String -> Effect Unit)
  -> Effect Unit

foreign import data ProseMirror :: Type

foreign import data Creator :: Type

foreign import data CodeEmitter :: Type
