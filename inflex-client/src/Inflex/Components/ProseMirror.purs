-- | ProseMirror component.

module Inflex.Components.ProseMirror
  ( component
  , Input, Query, Config, Output
  ) where

import Timed (timed)
import Data.Array (concatMap)
import Data.Either
import Data.Foldable
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.Map (Map)
import Data.Map as M
import Data.Maybe (Maybe(..))
import Data.Symbol (SProxy(..))
import Data.Tuple
import Data.UUID
import Data.UUID (UUID, uuidToString)
import Effect (Effect)
import Effect.Aff (Aff)
import Effect.Aff.Class (class MonadAff)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (log)
import Foreign.Object (Object)
import Halogen (Component, HalogenM, RefLabel(..), defaultEval, get, getHTMLElementRef, liftEffect, mkComponent, mkEval, put, raise, subscribe) as H
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Properties as HP
import Halogen.Portal as Portal
import Halogen.Query.EventSource (effectEventSource, emit) as H
import Inflex.Components.Cell.Editor.Types as EditorTypes
import Inflex.Frisson as F
import Inflex.Types (OutputCell(..))
import Prelude (class Show, Unit, bind, const, discard, mempty, pure, unit, void, (/=), (<<<), identity)
import Web.HTML.HTMLElement (HTMLElement)

--------------------------------------------------------------------------------
-- Interface

type Input = Map UUID OutputCell

type Output = Unit

data Query a = NoOp

--------------------------------------------------------------------------------
-- Internal protocol

type Slots a = (editor :: H.Slot EditorTypes.Query EditorTypes.Output UUID)

data State = State
  { allCells :: Map UUID (OutputCell)

  -- Below: The first UUID is a widget UUID generated by
  -- ProseMirror.js, the latter is an Inflex cell UUID.
  , embedCells :: Map UUID (Tuple UUID HTMLElement)
  }

data Command
  = Initializer
  | SetCells (Map UUID (OutputCell))
  | RegisterWidget UUID UUID HTMLElement

--------------------------------------------------------------------------------
-- Types

data Config = Config
  {
  }

data PMEvent
  = NoEvents

derive instance genericPMEvent :: Generic PMEvent _
instance showPMEvent :: Show PMEvent where show x = genericShow x

--------------------------------------------------------------------------------
-- Constants

refLabel :: H.RefLabel
refLabel = H.RefLabel "prosemirror"

--------------------------------------------------------------------------------
-- Component

component ::
     H.Component HH.HTML EditorTypes.Query EditorTypes.Input EditorTypes.Output Aff
  -> H.Component HH.HTML Query Input Output Aff
component editorComponent =
  H.mkComponent
    { initialState: initialState
    , render: \state -> timed "ProseMirror.render" (\_ -> render editorComponent state)
    , eval: H.mkEval
              H.defaultEval
                { handleAction = eval
                , receive = pure <<< SetCells
                , initialize = Just Initializer
                , handleQuery = query
                }
    }
  where
    initialState :: Input -> State
    initialState cells = State {
      allCells: cells,
      embedCells: mempty
      -- M.fromFoldable [Tuple (UUID "some-unique-id") (UUID "7190914a-9a54-477b-b5dc-da6b73edb7c9")]
     }

--------------------------------------------------------------------------------
-- Query

query ::
     forall m i a. MonadAff m =>
     Query a
  -> H.HalogenM State Command (Slots i) Output m (Maybe a)
query =
  case _ of
    NoOp -> do

      pure Nothing

--------------------------------------------------------------------------------
-- Eval

eval :: forall i t9. MonadEffect t9 => MonadAff t9 => Command -> H.HalogenM State Command (Slots i) Output t9 Unit
-- eval (CMEventIn event) =
--   H.raise (CMEventOut event)
eval (SetCells cells) = do
  log "SetCells in ProseMirror..."
  H.modify_ (\(State s) -> State (s {allCells = cells}))
eval (RegisterWidget proseUuid cellUuid element) =
   H.modify_ (\(State s) -> State (s {embedCells = M.insert proseUuid (Tuple cellUuid element) (s.embedCells)}))
eval Initializer = do
  State {} <- H.get
  melement <- H.getHTMLElementRef refLabel
  case melement of
    Nothing -> pure unit
    Just element -> do
      creator <- H.liftEffect newCreator
      void
        (H.subscribe
           (H.effectEventSource
              (\emitter -> do
                 setOnCreate creator (\proseUuid cellUuid element -> H.emit emitter (RegisterWidget (UUID proseUuid) (UUID cellUuid) element))
                 pure mempty)))
      _ <- H.liftEffect (proseMirror element creator)
      pure unit

--------------------------------------------------------------------------------
-- Render

render editorComponent (State{embedCells, allCells}) =
  HH.div
    [HP.ref refLabel
    ]
    (concatMap (\(Tuple proseUuid (Tuple cellUuid element)) ->
           case M.lookup cellUuid allCells of
             Nothing -> []
             Just (OutputCell cell) ->
               [Portal.portalAff
                EditorTypes.NewInput
                (SProxy :: SProxy "editor")
                proseUuid
                editorComponent
                (EditorTypes.EditorAndCode
                   { editor:
                     -- TODO: Refactor, the code below is the same as in Cell.purs.
                     F.caseResult
                        { "ResultError": Left
                        , "ResultOk": \resultTree -> Right (F.resultTreeTree resultTree)
                        }
                        (cell.result)
                   , code: cell.code
                   , cells: allCells
                   , path: identity
                   -- TODO: Refactor, the code below is the same as in Cell.purs.
                   , type': F.caseResult
                       { "ResultError": \_ -> Nothing
                       , "ResultOk": \resultTree -> Just (F.resultTreeTyp resultTree)
                       }
                       (cell.result)
                   })
                (Just element)
                (\output ->
                   case output of
                     -- TODO: Enable TriggerUpdatePath
                     EditorTypes.UpdatePath update -> Nothing -- Just (TriggerUpdatePath update)
                     -- TODO: Enable TriggerUpdatePath
                     EditorTypes.NewCode text ->
                       Nothing
                       -- Just
                       --   (TriggerUpdatePath
                       --      (Shared.UpdatePath
                       --         { path: Shared.DataHere
                       --         , update:
                       --             Shared.CodeUpdate (Shared.Code {text})
                       --         }))
                )


                ]
         )
         (M.toUnfoldable embedCells))

--------------------------------------------------------------------------------
-- Foreign

foreign import proseMirror
  :: HTMLElement
  -> Creator
  -> Effect ProseMirror

foreign import newCreator :: Effect Creator

foreign import setOnCreate
  :: Creator
  -> (String -> String -> HTMLElement -> Effect Unit)
  -> Effect Unit

foreign import data ProseMirror :: Type

foreign import data Creator :: Type
