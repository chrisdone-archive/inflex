{-# LANGUAGE GADTs, TemplateHaskell, ViewPatterns #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DuplicateRecordFields #-}
-- |

module ResolveSpec where

import           Data.Decimal
import           Data.List.NonEmpty (NonEmpty(..))
import qualified Data.List.NonEmpty as NE
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as M
import           Data.Text (Text)
import           Inflex.Generaliser
import           Inflex.Instances ()
import           Inflex.Resolver
import           Inflex.Solver as Solver
import           Inflex.Types
import           Match
import qualified RIO
import           Test.Hspec

resolveText' ::(e~()) =>
     Map Hash (Either e (Scheme Polymorphic))
  -> FilePath
  -> Text
  -> IO (Either (GeneraliseResolveError e) (IsResolved (Expression Resolved)))
resolveText' hash fp t = RIO.runRIO ResolveReader (resolveText hash fp t)

spec :: Spec
spec = do

  describe "Coarse-grained" coarseGrained

{-

Pretty much need row types to be able to have a productive expression
produce more than one type.

TODO: Test order of implicits for a global.
TODO: Test order of implicit parameters being correct.
TODO: Test multiple class constraints.

-}

coarseGrained :: Spec
coarseGrained = do
  fromInteger_123
  fromInteger_123_generic
  fromInteger_123_DecimalSig
  fromDecimal_fails
  lambda'dfromInteger_123
  fromIntegerFromInteger_123
  addIntegers
  addDecimals
  addOverloadedThings
  multipleOperators
  addOverloadedThingsWithSigs
  records

multipleOperators :: SpecWith ()
multipleOperators = do
  it
    "2 + 3 / 5"
    (shouldReturnSatisfy
       (resolveText' mempty "" "(2::Integer) + (3::Integer) / (5::Integer)")
       $(match [|Right (IsResolved {thing = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = InstanceGlobal (IntegerOpInstance AddOp), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}), left = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor ExpressionCursor, number = IntegerNumber 2, typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})})), right = InfixExpression (Infix {location = InfixRightCursor ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixRightCursor (InfixOpCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixRightCursor (InfixOpCursor ExpressionCursor), name = NumericBinOpGlobal DivideOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixRightCursor (InfixOpCursor ExpressionCursor)), name = InstanceGlobal (IntegerOpInstance DivideOp), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName})}), left = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), number = IntegerNumber 3, typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName})})), right = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (InfixRightCursor ExpressionCursor), number = IntegerNumber 5, typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixRightCursor ExpressionCursor), name = IntegerTypeName})})), typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName})}), typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}), scheme = Scheme {location = ExpressionCursor, constraints = [], typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 3, name = ""}}),(InfixLeftCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 5, name = ""}, end = SourcePos {line = 1, column = 12, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 17, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(InfixRightCursor (InfixOpCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 17, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(InfixRightCursor (InfixLeftCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 17, name = ""}, end = SourcePos {line = 1, column = 18, name = ""}}),(InfixRightCursor (InfixLeftCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 20, name = ""}, end = SourcePos {line = 1, column = 27, name = ""}}),(InfixRightCursor (InfixRightCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 32, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(InfixRightCursor (InfixRightCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 35, name = ""}, end = SourcePos {line = 1, column = 42, name = ""}})]})|]))
  it
    "2 + 3 / 5"
    (shouldReturnSatisfy
       (resolveText' mempty "" "2 + 3 / 5")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor (InfixRightCursor (InfixOpCursor ExpressionCursor)), param = Param {location = ImplicitArgumentFor (InfixRightCursor (InfixOpCursor ExpressionCursor)), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = LambdaExpression (Lambda {location = ImplicitArgumentFor BuiltIn, param = Param {location = ImplicitArgumentFor BuiltIn, name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = LambdaExpression (Lambda {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), param = Param {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = DeBrujinIndex (DeBrujinNesting 0), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), left = ApplyExpression (Apply {location = BuiltIn, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn BuiltIn, function = GlobalExpression (Global {location = BuiltIn, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor BuiltIn, name = DeBrujinIndex (DeBrujinNesting 1), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor ExpressionCursor, number = IntegerNumber 2, typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), right = InfixExpression (Infix {location = InfixRightCursor ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixRightCursor (InfixOpCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixRightCursor (InfixOpCursor ExpressionCursor), name = NumericBinOpGlobal DivideOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (InfixRightCursor (InfixOpCursor ExpressionCursor)), name = DeBrujinIndex (DeBrujinNesting 2), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), left = ApplyExpression (Apply {location = BuiltIn, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn BuiltIn, function = GlobalExpression (Global {location = BuiltIn, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor BuiltIn, name = DeBrujinIndex (DeBrujinNesting 1), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), number = IntegerNumber 3, typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixLeftCursor ExpressionCursor), name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), right = ApplyExpression (Apply {location = BuiltIn, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn BuiltIn, function = GlobalExpression (Global {location = BuiltIn, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor BuiltIn, name = DeBrujinIndex (DeBrujinNesting 1), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (InfixRightCursor ExpressionCursor), number = IntegerNumber 5, typ = ConstantType (TypeConstant {location = InfixRightCursor (InfixRightCursor ExpressionCursor), name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [ClassConstraint {className = DivideOpClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = InfixRightCursor (InfixOpCursor ExpressionCursor)},ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = BuiltIn},ClassConstraint {className = AddOpClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = InfixOpCursor ExpressionCursor}], typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 10, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 10, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 2, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 5, name = ""}, end = SourcePos {line = 1, column = 10, name = ""}}),(InfixRightCursor (InfixOpCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 5, name = ""}, end = SourcePos {line = 1, column = 10, name = ""}}),(InfixRightCursor (InfixLeftCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 5, name = ""}, end = SourcePos {line = 1, column = 6, name = ""}}),(InfixRightCursor (InfixRightCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 9, name = ""}, end = SourcePos {line = 1, column = 10, name = ""}})]})|]))

addOverloadedThings :: SpecWith ()
addOverloadedThings =
  it
    "fromInteger 2 + fromDecimal 3.0"
    (shouldReturnSatisfy
       (resolveText' mempty "" "@prim:from_integer (2::Integer) + @prim:from_decimal (3.0 :: Decimal 1)")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), param = Param {location = ImplicitArgumentFor (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = LambdaExpression (Lambda {location = ImplicitArgumentFor (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), param = Param {location = ImplicitArgumentFor (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = LambdaExpression (Lambda {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), param = Param {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = DeBrujinIndex (DeBrujinNesting 0), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), left = ApplyExpression (Apply {location = InfixLeftCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixLeftCursor (ApplyFuncCursor ExpressionCursor), name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), name = DeBrujinIndex (DeBrujinNesting 1), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor (ApplyArgCursor ExpressionCursor), number = IntegerNumber 2, typ = ConstantType (TypeConstant {location = InfixLeftCursor (ApplyArgCursor ExpressionCursor), name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), right = ApplyExpression (Apply {location = InfixRightCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixRightCursor (ApplyFuncCursor ExpressionCursor), name = FromDecimalGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), name = DeBrujinIndex (DeBrujinNesting 2), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), number = DecimalNumber (Decimal {places = 1, integer = 30}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}), location = InfixRightCursor (ApplyArgCursor ExpressionCursor), kind = TypeKind})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [ClassConstraint {className = FromDecimalClassName, typ = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}) :| [VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})], location = InfixRightCursor (ApplyFuncCursor ExpressionCursor)},ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = InfixLeftCursor (ApplyFuncCursor ExpressionCursor)},ClassConstraint {className = AddOpClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = InfixOpCursor ExpressionCursor}], typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 58, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 58, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 22, name = ""}}),(InfixLeftCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(InfixLeftCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 22, name = ""}}),(InfixLeftCursor (ApplyArgCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 24, name = ""}, end = SourcePos {line = 1, column = 31, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 55, name = ""}, end = SourcePos {line = 1, column = 58, name = ""}}),(InfixRightCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 35, name = ""}, end = SourcePos {line = 1, column = 53, name = ""}}),(InfixRightCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 55, name = ""}, end = SourcePos {line = 1, column = 58, name = ""}}),(InfixRightCursor (ApplyArgCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 62, name = ""}, end = SourcePos {line = 1, column = 71, name = ""}}),(InfixRightCursor (ApplyArgCursor (SignatureCursor (TypeApplyCursor TypeCursor))),SourceLocation {start = SourcePos {line = 1, column = 70, name = ""}, end = SourcePos {line = 1, column = 71, name = ""}})]})|]))

addOverloadedThingsWithSigs :: SpecWith ()
addOverloadedThingsWithSigs =
  it
    "fromInteger 2 + fromDecimal 3.0 :: Decimal 2"
    (shouldReturnSatisfy
       (resolveText' mempty "" "@prim:from_integer (2::Integer) + (@prim:from_decimal (3.0::Decimal 1) :: Decimal 2)")
       $(match [|Right (IsResolved {thing = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = InstanceGlobal (DecimalOpInstance 2 AddOp), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), left = ApplyExpression (Apply {location = InfixLeftCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixLeftCursor (ApplyFuncCursor ExpressionCursor), name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixLeftCursor (ApplyFuncCursor ExpressionCursor)), name = InstanceGlobal (FromIntegerDecimalInstance 2), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor (ApplyArgCursor ExpressionCursor), number = IntegerNumber 2, typ = ConstantType (TypeConstant {location = InfixLeftCursor (ApplyArgCursor ExpressionCursor), name = IntegerTypeName})})), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), right = ApplyExpression (Apply {location = InfixRightCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = InfixRightCursor (ApplyFuncCursor ExpressionCursor), name = FromDecimalGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixRightCursor (ApplyFuncCursor ExpressionCursor)), name = InstanceGlobal (FromDecimalDecimalInstance (FromDecimalInstance {supersetPlaces = 2, subsetPlaces = 1})), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 1}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), number = DecimalNumber (Decimal {places = 1, integer = 30}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (ApplyArgCursor ExpressionCursor), name = NatTypeName 1}), location = InfixRightCursor (ApplyArgCursor ExpressionCursor), kind = TypeKind})})), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [], typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)), name = NatTypeName 2}), location = InfixRightCursor (SignatureCursor TypeCursor), kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 59, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 59, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 22, name = ""}}),(InfixLeftCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(InfixLeftCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 22, name = ""}}),(InfixLeftCursor (ApplyArgCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 24, name = ""}, end = SourcePos {line = 1, column = 31, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 56, name = ""}, end = SourcePos {line = 1, column = 59, name = ""}}),(InfixRightCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 36, name = ""}, end = SourcePos {line = 1, column = 54, name = ""}}),(InfixRightCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 56, name = ""}, end = SourcePos {line = 1, column = 59, name = ""}}),(InfixRightCursor (ApplyArgCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 61, name = ""}, end = SourcePos {line = 1, column = 70, name = ""}}),(InfixRightCursor (ApplyArgCursor (SignatureCursor (TypeApplyCursor TypeCursor))),SourceLocation {start = SourcePos {line = 1, column = 69, name = ""}, end = SourcePos {line = 1, column = 70, name = ""}}),(InfixRightCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 75, name = ""}, end = SourcePos {line = 1, column = 84, name = ""}}),(InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 83, name = ""}, end = SourcePos {line = 1, column = 84, name = ""}})]})|]))

addIntegers :: SpecWith ()
addIntegers =
  it
    "2 + 3"
    (shouldReturnSatisfy
       (resolveText' mempty "" "(2::Integer) + (3::Integer)")
       $(match [|Right (IsResolved {thing = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = InstanceGlobal (IntegerOpInstance AddOp), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}), left = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor ExpressionCursor, number = IntegerNumber 2, typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})})), right = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor ExpressionCursor, number = IntegerNumber 3, typ = ConstantType (TypeConstant {location = InfixRightCursor ExpressionCursor, name = IntegerTypeName})})), typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}), scheme = Scheme {location = ExpressionCursor, constraints = [], typ = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = IntegerTypeName})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 18, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 18, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 3, name = ""}}),(InfixLeftCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 5, name = ""}, end = SourcePos {line = 1, column = 12, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 17, name = ""}, end = SourcePos {line = 1, column = 18, name = ""}}),(InfixRightCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 20, name = ""}, end = SourcePos {line = 1, column = 27, name = ""}})]})|]))

addDecimals :: SpecWith ()
addDecimals =
  it
    "2.23 + 3.23"
    (shouldReturnSatisfy
       (resolveText' mempty "" "(2.23 :: Decimal 2) + (3.23 :: Decimal 2)")
       $(match [|Right (IsResolved {thing = InfixExpression (Infix {location = ExpressionCursor, global = ApplyExpression (Apply {location = ImplicitlyApplicationOn (InfixOpCursor ExpressionCursor), function = GlobalExpression (Global {location = InfixOpCursor ExpressionCursor, name = NumericBinOpGlobal AddOp, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (InfixOpCursor ExpressionCursor), name = InstanceGlobal (DecimalOpInstance 2 AddOp), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind})}), left = LiteralExpression (NumberLiteral (Number {location = InfixLeftCursor ExpressionCursor, number = DecimalNumber (Decimal {places = 2, integer = 223}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind})})), right = LiteralExpression (NumberLiteral (Number {location = InfixRightCursor ExpressionCursor, number = DecimalNumber (Decimal {places = 2, integer = 323}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixRightCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixRightCursor ExpressionCursor, name = NatTypeName 2}), location = InfixRightCursor ExpressionCursor, kind = TypeKind})})), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [], typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = InfixLeftCursor ExpressionCursor, name = NatTypeName 2}), location = InfixLeftCursor ExpressionCursor, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 28, name = ""}}),(InfixOpCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 28, name = ""}}),(InfixLeftCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 2, name = ""}, end = SourcePos {line = 1, column = 6, name = ""}}),(InfixLeftCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 10, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(InfixLeftCursor (SignatureCursor (TypeApplyCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 18, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(InfixRightCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 24, name = ""}, end = SourcePos {line = 1, column = 28, name = ""}}),(InfixRightCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 32, name = ""}, end = SourcePos {line = 1, column = 41, name = ""}}),(InfixRightCursor (SignatureCursor (TypeApplyCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 40, name = ""}, end = SourcePos {line = 1, column = 41, name = ""}})]})|]))

fromIntegerFromInteger_123 :: SpecWith ()
fromIntegerFromInteger_123 =
  it
    "fromInteger (fromInteger 123)"
    (shouldReturnSatisfy
       (resolveText' mempty "" "@prim:from_integer (@prim:from_integer (123::Integer))")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), param = Param {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = ApplyExpression (Apply {location = ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (ApplyFuncCursor ExpressionCursor), function = GlobalExpression (Global {location = ApplyFuncCursor ExpressionCursor, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), name = DeBrujinIndex (DeBrujinNesting 0), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = ApplyExpression (Apply {location = ApplyArgCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (ApplyArgCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = ApplyArgCursor (ApplyFuncCursor ExpressionCursor), name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (ApplyArgCursor (ApplyFuncCursor ExpressionCursor)), name = InstanceGlobal FromIntegerIntegerInstance, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = TypeKind}))}), typ = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName})}), argument = LiteralExpression (NumberLiteral (Number {location = ApplyArgCursor (ApplyArgCursor ExpressionCursor), number = IntegerNumber 123, typ = ConstantType (TypeConstant {location = ApplyArgCursor (ApplyArgCursor ExpressionCursor), name = IntegerTypeName})})), typ = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = ApplyFuncCursor ExpressionCursor}], typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 41, name = ""}, end = SourcePos {line = 1, column = 44, name = ""}}),(ApplyFuncCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(ApplyArgCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 41, name = ""}, end = SourcePos {line = 1, column = 44, name = ""}}),(ApplyArgCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 39, name = ""}}),(ApplyArgCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 41, name = ""}, end = SourcePos {line = 1, column = 44, name = ""}}),(ApplyArgCursor (ApplyArgCursor (SignatureCursor TypeCursor)),SourceLocation {start = SourcePos {line = 1, column = 46, name = ""}, end = SourcePos {line = 1, column = 53, name = ""}})]})|]))

fromInteger_123 :: SpecWith ()
fromInteger_123 =
  it
    "fromInteger 123"
    (shouldReturnSatisfy
       (resolveText' mempty "" "@prim:from_integer (123::Integer)")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), param = Param {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = ApplyExpression (Apply {location = ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (ApplyFuncCursor ExpressionCursor), function = GlobalExpression (Global {location = ApplyFuncCursor ExpressionCursor, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), name = DeBrujinIndex (DeBrujinNesting 0), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = ApplyArgCursor ExpressionCursor, number = IntegerNumber 123, typ = ConstantType (TypeConstant {location = ApplyArgCursor ExpressionCursor, name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = ApplyFuncCursor ExpressionCursor}], typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 24, name = ""}}),(ApplyFuncCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(ApplyArgCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 24, name = ""}}),(ApplyArgCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 26, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}})]})|]))

fromInteger_123_generic :: SpecWith ()
fromInteger_123_generic =
  it
    "fromInteger 123"
    (shouldReturnSatisfy
       (resolveText' mempty "" "123")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor BuiltIn, param = Param {location = ImplicitArgumentFor BuiltIn, name = (), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, body = ApplyExpression (Apply {location = BuiltIn, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn BuiltIn, function = GlobalExpression (Global {location = BuiltIn, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor BuiltIn, name = DeBrujinIndex (DeBrujinNesting 0), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = ExpressionCursor, number = IntegerNumber 123, typ = ConstantType (TypeConstant {location = ExpressionCursor, name = IntegerTypeName})})), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), scheme = Scheme {location = BuiltIn, constraints = [ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = BuiltIn}], typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 4, name = ""}})]})|]))


lambda'dfromInteger_123 :: SpecWith ()
lambda'dfromInteger_123 =
  it
    "x:fromInteger x"
    (shouldReturnSatisfy
       (resolveText' mempty "" "x:@prim:from_integer(x)")
       $(match [|Right (IsResolved {thing = LambdaExpression (Lambda {location = ImplicitArgumentFor (LambdaBodyCursor (ApplyFuncCursor ExpressionCursor)), param = Param {location = ImplicitArgumentFor (LambdaBodyCursor (ApplyFuncCursor ExpressionCursor)), name = (), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = ExpressionCursor, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = ExpressionCursor, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = ExpressionCursor, kind = TypeKind})}, body = LambdaExpression (Lambda {location = ExpressionCursor, param = Param {location = LambdaParamCursor, name = (), typ = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName})}, body = ApplyExpression (Apply {location = LambdaBodyCursor ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (LambdaBodyCursor (ApplyFuncCursor ExpressionCursor)), function = GlobalExpression (Global {location = LambdaBodyCursor (ApplyFuncCursor ExpressionCursor), name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = VariableExpression (Variable {location = ImplicitArgumentFor (LambdaBodyCursor (ApplyFuncCursor ExpressionCursor)), name = DeBrujinIndex (DeBrujinNesting 1), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = BuiltIn, kind = TypeKind})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), argument = VariableExpression (Variable {location = LambdaBodyCursor (ApplyArgCursor ExpressionCursor), name = DeBrujinIndex (DeBrujinNesting 0), typ = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName})}), typ = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind})}), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = ExpressionCursor, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = ExpressionCursor, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = ExpressionCursor, kind = TypeKind})}), typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = ExpressionCursor, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = ExpressionCursor, kind = FunKind TypeKind TypeKind}), argument = PolyType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = ExpressionCursor, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [ClassConstraint {className = FromIntegerClassName, typ = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}) :| [], location = LambdaBodyCursor (ApplyFuncCursor ExpressionCursor)}], typ = ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = ExpressionCursor, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = ExpressionCursor, kind = FunKind TypeKind TypeKind}), argument = VariableType (TypeVariable {location = (), prefix = (), index = 0, kind = TypeKind}), location = ExpressionCursor, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 23, name = ""}}),(LambdaBodyCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 22, name = ""}, end = SourcePos {line = 1, column = 23, name = ""}}),(LambdaBodyCursor (ApplyFuncCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 3, name = ""}, end = SourcePos {line = 1, column = 21, name = ""}}),(LambdaBodyCursor (ApplyArgCursor ExpressionCursor),SourceLocation {start = SourcePos {line = 1, column = 22, name = ""}, end = SourcePos {line = 1, column = 23, name = ""}}),(LambdaParamCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 2, name = ""}})]})|]))

fromInteger_123_DecimalSig :: Spec
fromInteger_123_DecimalSig =
  it "fromInteger 123 :: Decimal 2"
     (shouldReturnSatisfy
        (resolveText' mempty "" "@prim:from_integer (123::Integer) :: Decimal 2")
        $(match [|Right (IsResolved {thing = ApplyExpression (Apply {location = ExpressionCursor, function = ApplyExpression (Apply {location = ImplicitlyApplicationOn (ApplyFuncCursor ExpressionCursor), function = GlobalExpression (Global {location = ApplyFuncCursor ExpressionCursor, name = FromIntegerGlobal, scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = NatTypeName 2}), location = SignatureCursor TypeCursor, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), argument = GlobalExpression (Global {location = ImplicitArgumentFor (ApplyFuncCursor ExpressionCursor), name = InstanceGlobal (FromIntegerDecimalInstance 2), scheme = ResolvedScheme (ApplyType (TypeApplication {function = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = FunctionTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = IntegerTypeName}), location = BuiltIn, kind = FunKind TypeKind TypeKind}), argument = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = BuiltIn, name = NatTypeName 2}), location = BuiltIn, kind = TypeKind}), location = BuiltIn, kind = TypeKind}))}), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = NatTypeName 2}), location = SignatureCursor TypeCursor, kind = TypeKind})}), argument = LiteralExpression (NumberLiteral (Number {location = ApplyArgCursor ExpressionCursor, number = IntegerNumber 123, typ = ConstantType (TypeConstant {location = ApplyArgCursor ExpressionCursor, name = IntegerTypeName})})), typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = NatTypeName 2}), location = SignatureCursor TypeCursor, kind = TypeKind})}), scheme = Scheme {location = ExpressionCursor, constraints = [], typ = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = DecimalTypeName}), argument = ConstantType (TypeConstant {location = SignatureCursor (TypeApplyCursor TypeCursor), name = NatTypeName 2}), location = SignatureCursor TypeCursor, kind = TypeKind})}, mappings = M.fromList [(ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 24, name = ""}}),(ApplyFuncCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 1, name = ""}, end = SourcePos {line = 1, column = 19, name = ""}}),(ApplyArgCursor ExpressionCursor,SourceLocation {start = SourcePos {line = 1, column = 21, name = ""}, end = SourcePos {line = 1, column = 24, name = ""}}),(ApplyArgCursor (SignatureCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 26, name = ""}, end = SourcePos {line = 1, column = 33, name = ""}}),(SignatureCursor TypeCursor,SourceLocation {start = SourcePos {line = 1, column = 38, name = ""}, end = SourcePos {line = 1, column = 47, name = ""}}),(SignatureCursor (TypeApplyCursor TypeCursor),SourceLocation {start = SourcePos {line = 1, column = 46, name = ""}, end = SourcePos {line = 1, column = 47, name = ""}})]})|]))

fromDecimal_fails :: Spec
fromDecimal_fails = do
  it
    "fromDecimal 12.0 :: Integer"
    (shouldReturn
       (resolveText' mempty "" "@prim:from_decimal (12.0::Decimal 1) :: Integer")
       (Left
          (ResolverErrors
             (pure
                (NoInstanceForType
                   FromDecimalClassName
                   (ConstantType
                      (TypeConstant
                         { location = SignatureCursor TypeCursor
                         , name = IntegerTypeName
                         })))))))
  it
    "fromDecimal 12.52 :: Decimal 1"
    (shouldReturn
       (resolveText' mempty "" "@prim:from_decimal (12.52 :: Decimal 2) :: Decimal 1")
       (Left
          (ResolverErrors
             (LiteralDecimalPrecisionMismatch
                (PrecisionMismatch
                   { supersetPlaces = 1
                   , subsetPlaces = 2
                   , constraint =
                       ClassConstraint
                         { className = FromDecimalClassName
                         , typ =
                             NE.fromList
                               [ ConstantType
                                   (TypeConstant
                                      { location =
                                          ApplyArgCursor ExpressionCursor
                                      , name = NatTypeName 2
                                      })
                               , ApplyType
                                   (TypeApplication
                                      { function =
                                          ConstantType
                                            (TypeConstant
                                               { location =
                                                   SignatureCursor
                                                     (TypeApplyCursor TypeCursor)
                                               , name = DecimalTypeName
                                               })
                                      , argument =
                                          ConstantType
                                            (TypeConstant
                                               { location =
                                                   SignatureCursor
                                                     (TypeApplyCursor TypeCursor)
                                               , name = NatTypeName 1
                                               })
                                      , location = SignatureCursor TypeCursor
                                      , kind = TypeKind
                                      })
                               ]
                         , location = ApplyFuncCursor ExpressionCursor
                         }
                   }) :|
              []))))
  it
    "fromDecimal (x : x)"
    (shouldReturn
       (resolveText' mempty "" "@prim:from_decimal (x : x)")
       (Left (GeneraliserErrored (SolverErrored (SolverError (Solver.TypeMismatch (EqualityConstraint {type1 = ConstantType (TypeConstant {location = BuiltIn, name = DecimalTypeName}), type2 = ApplyType (TypeApplication {function = ConstantType (TypeConstant {location = ApplyArgCursor ExpressionCursor, name = FunctionTypeName}), argument = VariableType (TypeVariable {location = ApplyArgCursor LambdaParamCursor, prefix = LambdaParameterPrefix, index = 2, kind = TypeKind}), location = ApplyArgCursor ExpressionCursor, kind = FunKind TypeKind TypeKind}), location = BuiltIn})))))))
  it
    "fromInteger 5 :: Integer -> Integer"
    (shouldReturn
       (resolveText' mempty "" "@prim:from_integer (5::Integer) :: Integer -> Integer")
       (Left
          (ResolverErrors
             (NE.fromList
                [ NoInstanceForType
                    FromIntegerClassName
                    (ApplyType
                       (TypeApplication
                          { function =
                              ApplyType
                                (TypeApplication
                                   { function =
                                       ConstantType
                                         (TypeConstant
                                            { location =
                                                SignatureCursor
                                                  (TypeApplyCursor
                                                     (TypeApplyCursor TypeCursor))
                                            , name = FunctionTypeName
                                            })
                                   , argument =
                                       ConstantType
                                         (TypeConstant
                                            { location =
                                                SignatureCursor
                                                  (TypeApplyCursor
                                                     (TypeApplyCursor TypeCursor))
                                            , name = IntegerTypeName
                                            })
                                   , location =
                                       SignatureCursor
                                         (TypeApplyCursor TypeCursor)
                                   , kind = FunKind TypeKind TypeKind
                                   })
                          , argument =
                              ConstantType
                                (TypeConstant
                                   { location =
                                       SignatureCursor
                                         (TypeApplyCursor TypeCursor)
                                   , name = IntegerTypeName
                                   })
                          , location = SignatureCursor TypeCursor
                          , kind = TypeKind
                          }))
                ]))))

records :: SpecWith ()
records = do
  it
    "{a:1}.a"
    (shouldReturn
       (fmap (fmap (\IsResolved {scheme} -> scheme)) (resolveText' mempty "" "{a:1}.a"))
       (Right
          (Scheme
             { location = ExpressionCursor
             , constraints =
                 [ ClassConstraint
                     { className = FromIntegerClassName
                     , typ =
                         VariableType
                           (TypeVariable
                              { location = ()
                              , prefix = ()
                              , index = 0
                              , kind = TypeKind
                              }) :|
                         []
                     , location = BuiltIn
                     }
                 ]
             , typ =
                 VariableType
                   (TypeVariable
                      {location = (), prefix = (), index = 0, kind = TypeKind})
             })))
  it
    "{a:1, b:2}.a"
    (shouldReturn
       (fmap
          (fmap (\IsResolved {scheme} -> scheme))
          (resolveText' mempty "" "{a:1,b:2}.a"))
       (Right
          (Scheme
             { location = ExpressionCursor
             , constraints =
                 [ ClassConstraint
                     { className = FromIntegerClassName
                     , typ =
                         VariableType
                           (TypeVariable
                              { location = ()
                              , prefix = ()
                              , index = 0
                              , kind = TypeKind
                              }) :|
                         []
                     , location = BuiltIn
                     }
                 ]
             , typ =
                 VariableType
                   (TypeVariable
                      {location = (), prefix = (), index = 0, kind = TypeKind})
             })))
  it
    "{a:1, b:2}.a * {a:1, b:2}.b"
    (shouldReturn
       (fmap
          (fmap (\IsResolved {scheme} -> scheme))
          (resolveText' mempty "" "{a:1,b:2}.a * {a:1,b:2}.b"))
       (Right
          (Scheme
             { location = ExpressionCursor
             , constraints =
                 [ ClassConstraint
                     { className = FromIntegerClassName
                     , typ =
                         VariableType
                           (TypeVariable
                              { location = ()
                              , prefix = ()
                              , index = 0
                              , kind = TypeKind
                              }) :|
                         []
                     , location = BuiltIn
                     }
                 , ClassConstraint
                     { className = MulitplyOpClassName
                     , typ =
                         VariableType
                           (TypeVariable
                              { location = ()
                              , prefix = ()
                              , index = 0
                              , kind = TypeKind
                              }) :|
                         []
                     , location = InfixOpCursor ExpressionCursor
                     }
                 ]
             , typ =
                 VariableType
                   (TypeVariable
                      {location = (), prefix = (), index = 0, kind = TypeKind})
             })))
